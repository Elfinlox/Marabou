

# Takes one MarabouNetworkNNEt object and layer l, and returns two MarabouNetworkNNet objects, generated by cutting the original network
# after layer l. Note that the input layer is considered layer 0.

def splitNNet(nnet,l):
    if (l<1) or (l>nnet.numLayers):
            print("nothing to do")
            return(False)
    weights1, weights2 = splitList(nnet.weights,l)
    biases1, biases2 = splitList(nnet.biases,l)

    new_input_size = nnet.layerSizes[l+1]


    mins1 = nnet.mins
    maxs1 = nnet.maxes

    means1 = nnet.means
    ranges1 = nnet.ranges



    maxs2 = [0]*new_input_size  #Not sure!
    mins2 = [0]*new_input_size  #Not sure!
    means2 = [0] * (new_input_size+1)  # Not sure!
    ranges2 = [0] * (new_input_size+1)  # Not sure!

    means2[-1] = nnet.means[-1]
    ranges2[-1] = nnet.ranges[-1]


    #NOTE that these choices may affect the evaluations! One should be careful with applying normalization.

    nnet1 = NNet(weights1,biases1,mins1,maxs1,means1,ranges1)
    nnet2 = NNet(weights2,biases2,mins2,maxs2,means2,ranges2)

    return nnet1,nnet2
